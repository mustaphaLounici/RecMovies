# -*- coding: utf-8 -*-
"""ClusterRatMatrix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rXPMGLDEPpvtOXnfXTAqGWWiSuLdHi0O
"""

from sklearn.cluster import KMeans
import skfuzzy as fuzz
import numpy as np
import pandas as pd

ml_url = "https://raw.githubusercontent.com/mustaphaLounici/RecMovies/master/ml-latest-small/ratings.csv"
df = pd.read_csv(ml_url)
print(df)

usersRawIds = np.array(list(set(df["userId"])))
i = 0
in2r_users = {}
r2in_users = {}

for id in usersRawIds:
    in2r_users[i] = id
    r2in_users[id] = i
    i = i+1


def getRawUserId(id):
    return in2r_users[id]


def getInnerUserId(id):
    return r2in_users[id]

itemsRawIds = np.array(list(set(df["movieId"])))

i = 0
in2r_items = {}
r2in_items = {}

for id in itemsRawIds:
    in2r_items[i] = id
    r2in_items[id] = i
    i = i+1


def getRawItemsId(id):
    return in2r_items[id]


def getInnerItemsId(id):
    return r2in_items[id]

ratMatrix = np.zeros((len(usersRawIds), len(itemsRawIds)))


for index, row in df.iterrows():
    userId = int(row['userId'])
    itemId = int(row['movieId'])
    rating = row['rating']
    ratMatrix[getInnerUserId(userId), getInnerItemsId(itemId)] = rating

print(ratMatrix)

ml_url = "https://raw.githubusercontent.com/mustaphaLounici/RecMovies/master/ml-latest-small/movies.csv"
itemsDf = pd.read_csv(ml_url)
print(itemsDf)

def mapUserToCategory(userRow):
    userCategory = {'Adventure': {'ratings': 0.0, 'cmp': 0}, 'Action': {'ratings': 0.0, 'cmp': 0}, 'Animation': {'ratings': 0.0, 'cmp': 0}, "Children": {'ratings': 0.0, 'cmp': 0}, 'Comedy': {'ratings': 0.0, 'cmp': 0}, 'Fantasy': {'ratings': 0.0, 'cmp': 0}, 'Romance': {'ratings': 0.0, 'cmp': 0}, 'Drama': {'ratings': 0.0, 'cmp': 0}, 'Crime': {'ratings': 0.0, 'cmp': 0}, 'Thriller': {'ratings': 0.0, 'cmp': 0}, 'Horror': {'ratings': 0.0, 'cmp': 0}, 'Mystery': {'ratings': 0.0, 'cmp': 0}, 'Sci-Fi': {'ratings': 0.0, 'cmp': 0}, 'Documentary': {'ratings': 0.0, 'cmp': 0}, 'IMAX': {'ratings': 0.0, 'cmp': 0}, 'War': {'ratings': 0.0, 'cmp': 0}, 'Musical': {'ratings': 0.0, 'cmp': 0}, 'Western': {'ratings': 0.0, 'cmp': 0}, 'Film-Noir': {'ratings': 0.0, 'cmp': 0}}
    for i in range(len(userRow)):
        rating = userRow[i]
        if rating == 0:
              continue
         
        category =itemsDf.loc[itemsDf["movieId"] == getRawItemsId(i)]
        category = category["genres"].values[0]
        category = category.split('|')
        
        for cat in category:
            if cat == "(no genres listed)":
              continue
            userCategory[cat]["ratings"] = userCategory[cat]["ratings"] + rating
            
            userCategory[cat]["cmp"] = userCategory[cat]["cmp"] + 1
             
    for cat in userCategory:
      if userCategory[cat]["ratings"] == 0 :
        userCategory[cat] = 0
      else :
        userCategory[cat] = userCategory[cat]["ratings"] / userCategory[cat]['cmp']
      
    return userCategory

def matByCategory (ratMatrix) :
  mat = []
  for user in ratMatrix :
    mat.append(list(mapUserToCategory(user).values()))
  return mat
catMatrix = matByCategory(ratMatrix)

# calc best K 
import matplotlib.pyplot as plt

Sum_of_squared_distances = []
K = range(1,20)
for k in K:
    km = KMeans(n_clusters=k)
    km = km.fit(np.array(catMatrix))
    Sum_of_squared_distances.append(km.inertia_)
    
plt.plot(K, Sum_of_squared_distances, 'bx-')
plt.xlabel('k')
plt.ylabel('Sum_of_squared_distances')
plt.title('Elbow Method For Optimal k (Kmeans) ')
plt.show()

# calc best K 
Sum_of_squared_distances = []
K = range(1,20)
data =np.transpose(np.array(catMatrix))
for k in K:
    cntr, u, u0, d, jm, p, fpc = fuzz.cluster.cmeans(
    data,k, 2, error=0.001, maxiter=900000, init=None)
    
    Sum_of_squared_distances.append(fpc)
    
plt.plot(K, Sum_of_squared_distances, 'bx-')
plt.xlabel('k')
plt.ylabel('fpc')
plt.title('Elbow Method For Optimal k (Cmeans)')
plt.show()

nbCluster = 5

from sklearn.cluster import AffinityPropagation
import numpy as np
clustering = AffinityPropagation().fit(np.array(catMatrix))
# print(clustering) 

print(clustering.labels_)

import collections
collections.Counter(clustering.labels_ )

# print(clustering.cluster_centers_)

kmeans = KMeans(n_clusters=nbCluster, random_state=0).fit(np.array(catMatrix))
print( kmeans.labels_ )
print(kmeans.inertia_)
import collections
collections.Counter(kmeans.labels_ )

cntr, u, u0, d, jm, p, fpc = fuzz.cluster.cmeans(
    np.transpose(np.array(catMatrix)),nbCluster, 2, error=0.005, maxiter=1000, init=None)
print(cntr,u)

import matplotlib.pyplot as plt

# (kmeans.cluster_centers_)
def scatter_plot(clusters,title):
  fig = plt.figure(figsize=(18, 5), dpi= 80)
  for c in clusters :
    x = ['Adventure', 'Action', 'Animation', 'Children', 'Comedy', 'Fantasy', 'Romance', 'Drama', 'Crime', 'Thriller', 'Horror', 'Mystery', 'Sci-Fi', 'Documentary', 'IMAX', 'War', 'Musical', 'Western', 'Film-Noir']
    y = c
    plt.scatter(x,y, s=80)
  plt.title(title,color='black',size='large')
  plt.grid()
  plt.show()

scatter_plot(cntr , title="Cmeans")
scatter_plot(kmeans.cluster_centers_,title="Kmeans")
scatter_plot(clustering.cluster_centers_,title="affinity")

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.spines import Spine
from matplotlib.projections.polar import PolarAxes
from matplotlib.projections import register_projection


def radar_factory(num_vars, frame='circle'):
  
    theta = np.linspace(0, 2*np.pi, num_vars, endpoint=False)

    def draw_poly_patch(self):
        # rotate theta such that the first axis is at the top
        verts = unit_poly_verts(theta + np.pi / 2)
        return plt.Polygon(verts, closed=True, edgecolor='k')

    def draw_circle_patch(self):
        # unit circle centered on (0.5, 0.5)
        return plt.Circle((0.5, 0.5), 0.5)

    patch_dict = {'polygon': draw_poly_patch, 'circle': draw_circle_patch}
    if frame not in patch_dict:
        raise ValueError('unknown value for `frame`: %s' % frame)

    class RadarAxes(PolarAxes):

        name = 'radar'
        # use 1 line segment to connect specified points
        RESOLUTION = 1
        # define draw_frame method
        draw_patch = patch_dict[frame]

        def __init__(self, *args, **kwargs):
            super(RadarAxes, self).__init__(*args, **kwargs)
            # rotate plot such that the first axis is at the top
            self.set_theta_zero_location('N')

        def fill(self, *args, **kwargs):
            """Override fill so that line is closed by default"""
            closed = kwargs.pop('closed', True)
            return super(RadarAxes, self).fill(closed=closed, *args, **kwargs)

        def plot(self, *args, **kwargs):
            """Override plot so that line is closed by default"""
            lines = super(RadarAxes, self).plot(*args, **kwargs)
            for line in lines:
                self._close_line(line)

        def _close_line(self, line):
            x, y = line.get_data()
            # FIXME: markers at x[0], y[0] get doubled-up
            if x[0] != x[-1]:
                x = np.concatenate((x, [x[0]]))
                y = np.concatenate((y, [y[0]]))
                line.set_data(x, y)

        def set_varlabels(self, labels):
            self.set_thetagrids(np.degrees(theta), labels)

        def _gen_axes_patch(self):
            return self.draw_patch()

        def _gen_axes_spines(self):
            if frame == 'circle':
                return PolarAxes._gen_axes_spines(self)
            # The following is a hack to get the spines (i.e. the axes frame)
            # to draw correctly for a polygon frame.

            # spine_type must be 'left', 'right', 'top', 'bottom', or `circle`.
            spine_type = 'circle'
            verts = unit_poly_verts(theta + np.pi / 2)
            # close off polygon by repeating first vertex
            verts.append(verts[0])
            path = Path(verts)

            spine = Spine(self, spine_type, path)
            spine.set_transform(self.transAxes)
            return {'polar': spine}

    register_projection(RadarAxes)
    return theta


def unit_poly_verts(theta):
 
    x0, y0, r = [0.5] * 3
    verts = [(r*np.cos(t) + x0, r*np.sin(t) + y0) for t in theta]
    return verts


def example_data(clusters):

    data = [
        ['Adventure', 'Action', 'Animation', 'Children', 'Comedy', 'Fantasy', 'Romance', 'Drama', 'Crime', 'Thriller', 'Horror', 'Mystery', 'Sci-Fi', 'Documentary', 'IMAX', 'War', 'Musical', 'Western', 'Film-Noir']
    ]
    
    
    i  = 1
#     data.append(("profils" ,clusters))
    for c in clusters:
      data.append(("Profil " + str(i) ,[c]))
      i = i +1
    return data

def radar_clusters(viz_title,clusters,rows=2,cols=3):
  N = 19
  theta = radar_factory(N, frame='polygon')

  data = example_data(clusters)
  #     cntr
  # kmeans.cluster_centers_
  spoke_labels = data.pop(0)

  fig, axes = plt.subplots(figsize=(17, 17), nrows=rows, ncols=cols,
                           subplot_kw=dict(projection='radar'))
  fig.subplots_adjust(wspace=0.4, hspace=0.4, top=0.5, bottom=0.05)

  colors = ['b', 'r', 'g', 'm', 'y']

  for ax, (title, case_data) in zip(axes.flatten(), data):

      ax.set_title(title, weight='bold', size='medium', position=(0.5, 1.1),
                   horizontalalignment='center', verticalalignment='center')
      
      for d, color in zip(case_data, colors):
          ax.plot(theta, d, color=color)
          ax.fill(theta, d, facecolor=color, alpha=0.25)
      ax.set_varlabels(spoke_labels)

  plt.show()
#%%
radar_clusters("afinity",clustering.cluster_centers_,rows=8, cols=4)

radar_clusters("Kmeans",kmeans.cluster_centers_)

radar_clusters("Cmeans",cntr)

from surprise import AlgoBase
from surprise import Dataset
from surprise.model_selection import cross_validate

# getCluster(UserId)

#cas 1 sans cluster
class RecAlgo1(AlgoBase):

    def __init__(self):
        AlgoBase.__init__(self)
        self.verbose = True

        
    def fit(self, trainset):
        AlgoBase.fit(self, trainset)
        
        print(list(trainset.all_users()))
#         build the Ratmatrix
#         build the categoryMatrix
#         clusters
#         get clusters Mat

#         self.sim = self.compute_similarities()

        
        return self

    def estimate(self, u, i):
#       if not (self.trainset.knows_user(u) and self.trainset.knows_item(i)):
#             raise PredictionImpossible('User and/or item is unkown.')
          
#       neighbors = [(v, self.sim[u, v]) for (v, r) in self.trainset.ir[i]]
      
      # Sort these neighbors by similarity
#       neighbors = sorted(neighbors, key=lambda x: x[1], reverse=True)

#       print('The 3 nearest neighbors of user', str(u), 'are:')
#       for v, sim_uv in neighbors[:3]:
#           print('user {0:} with sim {1:1.2f}'.format(v, sim_uv))
      
      
#       print(self.sim)
      return 4
    
data = Dataset.load_builtin('ml-100k')
algo = RecAlgo1()

cross_validate(algo, data, verbose=True,cv=2)

